% function AirTraffic_SensorControl()
clear all
clc 
close all

%  matlabpool open 10
%% ------------------------------------------------------------------------
% time
%--------------------------------------------------------------------------
time.t0 = 0;
time.dt = 5;
time.tf = 125+90+125+30+125;
time.tspan = time.t0 : time.dt : time.tf;
time.nSteps = length(time.tspan);
%__________________________________________________________________________

%% ------------------------------------------------------------------------
% model
T=time.dt;
L1=0.2;
L2=0.01;
Q_CT=L1*[T^3/3,0,T^2/2,0,0;
        0,T^3/3,0,T^2/2,0;
        T^2/2,0,T,0,0;
        0,T^2/2,0,T,0;
        0,0,0,0,T*L2/L1];
%     Q_UM=Q_CT(1:4,1:4);
%  R=diag([(200)^2,(1*pi/180)^2]);    
    R=diag([(500)^2,(100)^2]);     
alpha1=5*pi/180;
alpha2=2*pi/180;
 
 sens.xc1=[-1.6,-1.6]*1e4;
 sens.xc2=[1,-1.6]*1e4;
 
 
model.fn = 5;               % state space dimensionality
model.fx = @KIRB_CT_eg_dyn_disc;
model.fx_jac=@KIRB_CT_eg_dyn_jac_disc;
model.hn = 2;               % measurement dimensionality
model.hx =@(x,para)[sqrt((x(1)-sens.xc1(1))^2+(x(2)-sens.xc1(2))^2),sqrt((x(1)-sens.xc2(1))^2+(x(2)-sens.xc2(2))^2)];
model.gx =@(x,para)[sensor_radial_penalty(x,sens.xc1,[para(1),alpha1]),0;0,sensor_radial_penalty(x,sens.xc2,[para(2),alpha2])];
% model.gx =@(x,phi)[1,0;0,1];
model.hx_jac=@KIRB_eg_meas_jac_disc2;
model.Q = Q_CT;
model.sQ = sqrtm(model.Q);
model.R = R;
model.sR=sqrtm(R);
model.Qtruth=1e-200;
model.x0tr=[25000,10000,-120,0]';
% model parameters that change with time and sent into the model equations 
% for every evaluation.
model.para_dt(1)=T;
model.para_dt(2)=pi/4;% second parameter value is sensor orientation 'phi'
model.frequpdt=ones(1,time.nSteps);
%% ------------------------------------------------------------------------
% particle filter settings
%--------------------------------------------------------------------------
pf.no_particles = 5000;
pf.no_bins = 1000;               % when computing the histogram

pf.resample = true;             % resampling after measurement update
pf.neff = 0.8;                  % treshold for the number of effective samples


%% --------------------------------------------------------------
%filter props
x0tr_CT=[25000,10000,-120,0,0.0005]';
P0tr_CT=diag([1000^2,1000^2,100,100,(2*pi/180)^2]);
filter.paras_ukf_kappa=1;
filter.paras_gh_pts=4;
filter.freq=1; %% This is actually the number of 'dt' steps after which a meas updt is done
filter.P0_filt_start=P0tr_CT;
filter.save_pf_data='false';
%switch on filters
filter.EKF='true';
filter.CKF='true';
filter.UKF='true';
filter.KF='false';
filter.GHKF='true';
filter.PF='true';
filter.CUT4KF='true';
filter.CUT6KF='true';
filter.CUT8KF='true';
filter.truth=[];
filter.ymeas=[];
%% --------------------------------------------------------------------
% Gaussian mixture components
GMM.ng=2;
X0=mvnrnd(x0tr_CT',P0tr_CT,floor( pf.no_particles/4));
options = statset('MaxIter',5000);
obj = gmdistribution.fit(X0,GMM.ng,'SharedCov',true,'Options',options);
GMM.mu=obj.mu;
% GMM.mu=GMM.mu+mvnrnd(x0tr_CT',0.00001*P0tr_CT,GMM.ng);
GMM.P=repmat(reshape(obj.Sigma,1,model.fn^2),GMM.ng,1);
GMM.w=obj.PComponents';
GMM.method='GH';
GMM.kappa=1;
GMM.ghpts=4;
%use adaptive weights or not
GMM.wtup=0;
%optimize the sensor config 1
% just use the prior mean anagle 2
% finf max in +-10 deg 3
GMM.opt=1;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Create the NNN data sets in a cell to sent to parfor lloop

    % firstly generating the truth
    [t,x_mc1]=ode45_discc(@(x)KIRB_UM_eg_dyn_disc(x,model.para_dt),time.t0,time.dt,125,model.x0tr,1e-200);
    [t,x_mc2]=ode45_discc(@(x)KIRB_CT_eg_dyn_disc(x,model.para_dt),t(end),time.dt,t(end)+90,[x_mc1(end,:)';1*pi/180],1e-200);
    [t,x_mc3]=ode45_discc(@(x)KIRB_UM_eg_dyn_disc(x,model.para_dt),t(end),time.dt,t(end)+125,x_mc2(end,1:end-1)',1e-200);
    [t,x_mc4]=ode45_discc(@(x)KIRB_CT_eg_dyn_disc(x,model.para_dt),t(end),time.dt,t(end)+30,[x_mc3(end,:)';-3*pi/180],1e-200);
    [t,x_mc5]=ode45_discc(@(x)KIRB_UM_eg_dyn_disc(x,model.para_dt),t(end),time.dt,t(end)+125,x_mc4(end,1:end-1)',1e-200);
    x_mc=[[x_mc1(1:end-1,1:4),zeros(size(x_mc1,1)-1,1)];x_mc2(1:end-1,1:5);[x_mc3(1:end-1,1:4),zeros(size(x_mc3,1)-1,1)];x_mc4(1:end-1,1:5);[x_mc5(1:end,1:4),zeros(size(x_mc5,1),1)]];


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
x_gmm=zeros(time.nSteps,model.fn);
zk=zeros(time.nSteps,model.hn);
x_gmm(1,:)=x0tr_CT';
mu_gh=mvnrnd(x0tr_CT,P0tr_CT,1)';
P_gh=P0tr_CT;
x_gh=zeros(time.nSteps,model.fn);
x_gh(1,:)=mu_gh';

model.para_dt(2)=atan2(x0tr_CT(2)-xc1(2),x0tr_CT(1)-xc1(1));
model.para_dt(3)=atan2(x0tr_CT(2)-xc2(2),x0tr_CT(1)-xc2(1));

for j=2:1:time.nSteps

       
%        zm=ym(j,:)';

        [GMM,model,zm]=GMMF(GMM,model,j,x_mc);
%          [mu_gh,P_gh]=QUADpt_filter_disc_UPDT_disc_MEAS(model,mu_gh,P_gh,zm,'gh',filter.paras_gh_pts); 
        zk(j,:)=fsolve(@(z)[(z(1)-xc1(1))^2+(z(2)-xc1(2))^2-zm(1)^2;(z(1)-xc2(1))^2+(z(2)-xc2(2))^2-zm(2)^2],GMM.mean(1:2));

    
    

x_gmm(j,:)=GMM.mean';
x_gh(j,:)=mu_gh';
plot(x_mc(:,1),x_mc(:,2),'r--',x_gmm(1:j,1),x_gmm(1:j,2),'b*-',zk(1:j,1),zk(1:j,2),'k+','Linewidth',2)
 plot_sens_view(xc1,alpha1,model.para_dt(2),5*10^4)
plot_sens_view(xc2,alpha2,model.para_dt(3),5*10^4)
 
axis([-1.7,2.8,-1.7,1.5]*10^4)
pause(0.1)
end